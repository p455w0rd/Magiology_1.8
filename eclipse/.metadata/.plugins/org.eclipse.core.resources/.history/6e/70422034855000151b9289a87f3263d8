package com.magiology.objhelper.helpers;

import java.util.Random;

import jdk.nashorn.internal.ir.LiteralNode.ArrayLiteralNode.ArrayUnit;

import org.apache.commons.lang3.ArrayUtils;

import com.magiology.objhelper.helpers.Helper.H;

import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumFacing;

public class SideHelper{
	
	static int[] x={0,0,0,1,0,-1};
	static int[] y={1,-1,0,0,0,0};
	static int[] z={0,0,-1,0,1,0};
	static Random rand = new Random();
	
//	switch(EnumFacing){
//	case 0:{y+=1;}break;
//	case 1:{y-=1;}break;
//	case 2:{z-=1;}break;
//	case 3:{x+=1;}break;
//	case 4:{z+=1;}break;
//	case 5:{x-=1;}break;
//	}
	
	public static int getOppositeSide(int side){
		int result=-1;
		switch(side){
		case 0:result=1;break;
		case 1:result=0;break;
		case 2:result=3;break;
		case 3:result=2;break;
		case 4:result=5;break;
		case 5:result=4;break;
		}
//		Helper.printInln(EnumFacing.getFront(5));
		return result;
	}
	
	
	public static BlockPos offset(int side,BlockPos pos){
		return pos.add(x[side],y[side],z[side]);
	}
	public static BlockPos offsetNew(int side,BlockPos pos){
		return pos.offset(EnumFacing.getFront(side));
	}
	public static int[] randomizeSides(){
		int side[]=new int[6],newSide=0,i=0;
		
		for(int j=0;j<6;j++){
			do{newSide=rand.nextInt(6);}while(!ArrayUtils.contains(side, newSide));
			side=ArrayUtils.add(side, newSide);
		}
		
		return side;
	}


	public static int enumFacingOrientation(EnumFacing fDir){
		if(fDir==null)return -1;
		return fDir.getIndex();
	}
	public static int DOWN(){
		return enumFacingOrientation(EnumFacing.DOWN);
	}
	public static int UP(){
		return enumFacingOrientation(EnumFacing.UP);
	}
	public static int NORTH(){
		return enumFacingOrientation(EnumFacing.NORTH);
	}
	public static int SOUTH(){
		return enumFacingOrientation(EnumFacing.SOUTH);
	}
	public static int WEST(){
		return enumFacingOrientation(EnumFacing.WEST);
	}
	public static int EAST(){
		return enumFacingOrientation(EnumFacing.EAST);
	}
	public static TileEntity[] getTilesOnSides(TileEntity tileEntity){
		TileEntity[] result=new TileEntity[6];
		if(tileEntity!=null)for(int i=0;i<6;i++)result[i]=tileEntity.getWorld().getTileEntity(offsetNew(i, tileEntity.getPos()));
		return result;
	}


	public static int convert(int side){
		return side;
//		switch(side){
//		case 0:return 0;
//		case 1:return 1;
//		case 2:return 4;
//		case 3:return 2;
//		case 4:return 3;
//		case 5:return 5;
//		}
//		return -1;
	}
}
