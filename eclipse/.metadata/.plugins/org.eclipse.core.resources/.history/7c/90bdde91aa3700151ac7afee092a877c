package com.magiology.mcobjects.blocks;

import java.util.List;

import net.minecraft.block.material.Material;
import net.minecraft.entity.Entity;
import net.minecraft.util.AxisAlignedBB;
import net.minecraft.util.BlockPos;
import net.minecraft.util.MovingObjectPosition;
import net.minecraft.world.IBlockAccess;
import net.minecraft.world.World;

import com.magiology.forgepowered.event.ForcePipeUpdate;
import com.magiology.mcobjects.tileentityes.corecomponents.MultiColisionProvider;
import com.magiology.mcobjects.tileentityes.corecomponents.MultiColisionProvider.MultiColisionProviderRayTracer;
import com.magiology.objhelper.vectors.Vec3M;

public abstract class BlockContainerMultiColision extends BlockContainerM{

	protected BlockContainerMultiColision(Material material){
		super(material);
		if(!(createNewTileEntity(null, 0) instanceof MultiColisionProvider))throw new IllegalStateException("BlockContainerMultiColision has to be provided with a TileEntity that implements MultiColisionProvider class!");
	}
	@Override
	public int getRenderType(){return -1;}
	@Override
	public boolean isOpaqueCube(){return false;}
    
    @Override
	public void onNeighborChange(IBlockAccess world, BlockPos pos, BlockPos neighbor){
    	ForcePipeUpdate.updatein3by3((World)world,pos);
    }
    
    @Override
	public void onPostBlockPlaced(World world, BlockPos pos, int md){
    	ForcePipeUpdate.updatein3by3(world,pos);
	}
    
    @Override
	public MovingObjectPosition collisionRayTrace(World w, BlockPos pos, Vec3M startVec, Vec3M endVec){
    	if(!MultiColisionProviderRayTracer.isRayTracing){
        	int id=MultiColisionProviderRayTracer.getRayTracedBoxId(w, x, y, z, startVec, endVec, getResetBoundsOptionalFix(w, x, y, z));
        	return MultiColisionProviderRayTracer.results[id];
    	}else return super.collisionRayTrace(w, x, y, z, startVec, endVec);
    }
    
    public abstract AxisAlignedBB getResetBoundsOptional(World world, BlockPos pos);
    private AxisAlignedBB getResetBoundsOptionalFix(World world, BlockPos pos){
    	AxisAlignedBB result=getResetBoundsOptional(world, x, y, z);
    	if(result==null)return null;
    	if(result.minX<0)result.minX=0;
    	if(result.minY<0)result.minY=0;
    	if(result.minZ<0)result.minZ=0;
    	if(result.maxX>1)result.maxX=1;
    	if(result.maxY>1)result.maxY=1;
    	if(result.maxZ>1)result.maxZ=1;
    	return result;
    }
    
    @Override
    public void addCollisionBoxesToList(World world, BlockPos pos, AxisAlignedBB aaBB, List list, Entity entity){
		AxisAlignedBB[] a=((MultiColisionProvider)world.getTileEntity(x, y, z)).getActiveBoxes();
		for(int i=0;i<a.length;i++){
			this.setBlockBounds((float)a[i].minX,(float)a[i].minY,(float)a[i].minZ,(float)a[i].maxX,(float)a[i].maxY,(float)a[i].maxZ);
			super.addCollisionBoxesToList(world, x, y, z, aaBB, list, entity);
		}
    }
    
}
