package com.magiology.mcobjects.tileentityes.corecomponents;

import java.util.Set;
import java.util.Map.Entry;

import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.network.NetworkManager;
import net.minecraft.network.Packet;
import net.minecraft.network.play.server.S35PacketUpdateTileEntity;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumFacing;

import com.magiology.api.connection.Connection;
import com.magiology.api.connection.ConnectionType;
import com.magiology.api.connection.IConnection;
import com.magiology.api.connection.IConnectionFactory;
import com.magiology.api.connection.IConnectionProvider;
import com.magiology.objhelper.helpers.Helper.H;

public abstract class TileEntitySided extends TileEntityM implements UpdateableTile{
	
	public IConnection[] connections=IConnectionFactory.NewArray(this, ConnectionType.Energy);
	
	@Override
	public TileEntity getHost(){
		return this;
	}
	@Override
	public IConnection[] getConnections(){
		return connections;
	}
	@Override
	public boolean isStrate(EnumFacing facing){
		if(facing==EnumFacing.UP||facing==EnumFacing.DOWN||facing==null){
			if((connections[0].getMain()&&connections[1].getMain())&&(connections[2].getMain()==false&&connections[3].getMain()==false&&connections[4].getMain()==false&&connections[5].getMain()==false))return true;
		}
		if(facing==EnumFacing.WEST||facing==null){
			if((connections[4].getMain()&&connections[5].getMain())&&(connections[1].getMain()==false&&connections[0].getMain()==false&&connections[2].getMain()==false&&connections[3].getMain()==false))return true;
		}
		if(facing==EnumFacing.SOUTH||facing==null){
			if((connections[2].getMain()&&connections[3].getMain())&&(connections[1].getMain()==false&&connections[0].getMain()==false&&connections[4].getMain()==false&&connections[5].getMain()==false))return true;
		}
		return false;
	}
	
	public static void writeIConnections(IConnection[] connections,NBTTagCompound NBT,String tag){
		NBTTagList list= new NBTTagList();
		for(int i=0;i<connections.length;i++){
			NBTTagCompound connection=new NBTTagCompound();
			IConnection con=connections[i];
			
			connection.setByte("face", (byte)con.getFaceI());
			connection.setByte("type", (byte)con.getType().id);
			connection.setBoolean("main", con.getMain());
			connection.setBoolean("in", con.getIn());
			connection.setBoolean("out", con.getOut());
			connection.setBoolean("banned", con.isBanned());
			connection.setBoolean("MA", con.isMainAutomatic());
			Set<Entry<String, String>> k=con.getAllExtra().entrySet();
			connection.setInteger("extraSize", k.size());
			int count=0;
			for(Entry<String, String> j:k){
				connection.setString("k"+count, j.getKey());
				connection.setString("v"+count, j.getValue());
				count++;
			}
			list.appendTag(connection);
		}
		NBT.setTag(tag+"Cons", list);
	}
	public static IConnection[] readIConnections(IConnectionProvider host,NBTTagCompound NBT, String tag){
		IConnection[] result=new IConnection[6]; 
		NBTTagList list= NBT.getTagList(tag+"Slots", 10);
		int size=6;
    	for(int i=0;i<list.tagCount();i++){
    		NBTTagCompound connection=list.getCompoundTagAt(i);
			result[i]=new Connection(host, 
			ConnectionType.values()[connection.getByte("type")], 
			EnumFacing.getFront(connection.getByte("face")));
			IConnection con=result[i];
			con.setMain(connection.getBoolean("main"));
    		con.setIn(connection.getBoolean("in"));
    		con.setOut(connection.getBoolean("out"));
    		con.setBanned(connection.getBoolean("banned"));
    		con.setIsMainAutomatic(connection.getBoolean("MA"));
    		int extraSize=connection.getInteger("extraSize");
    		for(int j=0;j<extraSize;j++)con.setExtra(connection.getString("k"+j), connection.getString("v"+j));
    	}
		return result;
	}
}
