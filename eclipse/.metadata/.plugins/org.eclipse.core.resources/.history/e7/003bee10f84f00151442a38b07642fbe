package com.magiology.mcobjects.tileentityes.corecomponents.powertiles;

import java.util.List;

import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.server.gui.IUpdatePlayerListBox;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.BlockPos;

import com.magiology.api.power.ISidedPower;
import com.magiology.api.power.PowerUpgrades;
import com.magiology.mcobjects.tileentityes.TileEntityBateryGeneric;
import com.magiology.mcobjects.tileentityes.TileEntityFirePipe;
import com.magiology.mcobjects.tileentityes.corecomponents.TileEntityConnectionProvider;
import com.magiology.objhelper.helpers.Helper;
import com.magiology.objhelper.helpers.LogHelper;
import com.magiology.objhelper.helpers.PowerHelper.PowerItemHelper;
import com.magiology.registry.upgrades.RegisterItemUpgrades.Container;

public abstract class TileEntityPow extends TileEntityConnectionProvider implements ISidedPower,PowerUpgrades,IUpdatePlayerListBox{
	public int currentEnergy=0,maxTSpeed=0,middleTSpeed=0,minTSpeed=1,maxEnergyBuffer=0;
	public boolean
		keepsPropertiesOnPickup=false,
		hasPriorityUpg=false;
	public int FirstSide=-1;
	
	public Container container=null;
	public int NumberOfContainerSlots=0;
	public ItemStack[] containerItems=null;
	
	public TileEntityPow(boolean[] changeableByUser,boolean[] sidedPower,int minTSpeed, int middleTSpeed, int maxTSpeed, int maxEnergyBuffer){
		if(changeableByUser!=null)for(int i=0;i<6;i++){
			connections[i].setInEnabled(changeableByUser[i]);
			connections[i].setOutEnabled(changeableByUser[i+6]);
		}
		if(sidedPower!=null)for(int i=0;i<6;i++){
			connections[i].setIn(sidedPower[i]);
			connections[i].setOut(sidedPower[i+6]);
		}
		this.minTSpeed=minTSpeed;
		this.middleTSpeed=middleTSpeed;
		this.maxTSpeed=maxTSpeed;
		this.maxEnergyBuffer=maxEnergyBuffer;
	}
	
    @Override
	public void readFromNBT(NBTTagCompound NBTTC){
		super.readFromNBT(NBTTC);
        currentEnergy = NBTTC.getInteger("energy");
        
        containerItems=new ItemStack[NumberOfContainerSlots];
        containerItems=Helper.loadItemsFromNBT(NBTTC, "TEMT", containerItems);
    }
    
    @Override
	public void writeToNBT(NBTTagCompound NBTTC){
		super.writeToNBT(NBTTC);
    	NBTTC.setInteger("energy", currentEnergy);
    	if(containerItems!=null){
    		Helper.saveItemsToNBT(NBTTC, "TEMT", containerItems);
        }
    }
    
    
    @Override
	public void initUpgrades(Container containe){
    	container=containe;
		NumberOfContainerSlots=container.getNumberOfTypes();
		setUpgradeSlots();
    }
    
    public void setUpgradeSlots(){
    	if(NumberOfContainerSlots>0)containerItems=new ItemStack[NumberOfContainerSlots];
    }
    
	public boolean isTPipe(BlockPos pos){
		return worldObj.getTileEntity(pos)instanceof TileEntityFirePipe;
	}
	

	public boolean canAcceptThatMuchEnergy(int amout){
		return (maxEnergyBuffer-amout>=currentEnergy?true:false);
	}
	
	public boolean isAnyBatery(BlockPos pos){
		boolean return1=false;
		TileEntity tile=worldObj.getTileEntity(pos);
		
		if(tile instanceof TileEntityBateryGeneric){
			return1=true;
		}
		
		return return1;
	}
	
	@Override
	public void addEnergy(int amount){currentEnergy+=amount;}
	@Override
	public void subtractEnergy(int amount){currentEnergy-=amount;}
    
    @Override
	public boolean isUpgradeInInv(Item item){
    	for(int a=0;a<NumberOfContainerSlots;a++){
    		if(Helper.isItemInStack(item, containerItems[a]))return true;
    	}
    	return false;
    }
	@Override
	public Container getContainer(){
		return container;
	}
	@Override
	public int getNumberOfContainerSlots(){
		return NumberOfContainerSlots;
	}
	@Override
	public ItemStack[] getcontainerItems(){
		return containerItems;
	}
	@Override
	public void setContainer(Container container){
		this.container=container;
	}
	@Override
	public void setNumberOfContainerSlots(int Int){
		NumberOfContainerSlots=Int;
	}
	@Override
	public void setcontainerItems(ItemStack[] containerItems){
		this.containerItems=containerItems;
	}
	@Override
	public boolean getReceiveOnSide(int direction){
		try {
			return connections[direction].getIn();
		} catch (Exception e){
			Helper.printInln(connections);
			Helper.exit(404);
			return false;
		}
	}
	@Override
	public boolean getSendOnSide(int direction){
		return connections[direction].getOut();
	}
	@Override
	public void setReceaveOnSide(int direction, boolean bolean){
		connections[direction].setIn(bolean);
	}
	@Override
	public void setSendOnSide(int direction, boolean bolean){
		connections[direction].setOut(bolean);
	}
	@Override
	public int getEnergy(){
		return currentEnergy;
	}
	@Override
	public int getMaxTSpeed(){
		return maxTSpeed;
	}
	@Override
	public int getMiddleTSpeed(){
		return middleTSpeed;
	}
	@Override
	public int getMinTSpeed(){
		return minTSpeed;
	}
	@Override
	public int getMaxEnergy(){
		return maxEnergyBuffer;
	}
	@Override
	public void setEnergy(int Int){
		currentEnergy=Int;
	}
	@Override
	public void setMaxTSpeed(int Int){
		maxTSpeed=Int;
	}
	@Override
	public void setMiddleTSpeed(int Int){
		middleTSpeed=Int;
	}
	@Override
	public void setMinTSpeed(int Int){
		minTSpeed=Int;
	}
	@Override
	public void setMaxEnergyBuffer(int Int){
		maxEnergyBuffer=Int;
	}
	@Override
	public boolean getAllowedSender(int id){
		if(id<0||id>6){
			LogHelper.fatal(id);
			return false;
		}
		return connections[id].getOutEnabled();
	}
	@Override
	public boolean getAllowedReceaver(int id){
		if(id<0||id>6){
			LogHelper.fatal(id);
			return false;
		}
		return connections[id].getInEnabled();
	}
	@Override
	public void setAllowedSender(boolean Boolean, int id){
		connections[id].setOutEnabled(Boolean);
	}
	@Override
	public void setAllowedReceaver(boolean Boolean, int id){
		connections[id].setInEnabled(Boolean);
	}
	
	@Override
	public boolean getBannedSide(int id){
		return connections[id].isBanned();
	}
	@Override
	public void setBannedSide(boolean Boolean, int id){
		connections[id].setBanned(Boolean);
	}
	@Override
	public boolean isPowerKeptOnWrench(){
		return true;
	}
	@Override
	public void readFromItemOnPlace(ItemStack stack){
		setEnergy(PowerItemHelper.getPower(stack));
	}
	@Override
	public void writeToItemOnWrenched(ItemStack stack){
		PowerItemHelper.setEssencialPow(stack, this);
	}
	@Override
	public boolean isSavingFullNBT(){
		return true;
	}
	
	@Override
	public void getValidTileEntitys(List<Class> included, List<Class> excluded){
		
	}
	
	@Override
	public <T extends TileEntity> boolean getExtraClassCheck(Class<T> clazz, T tile, Object[] array, int side){
		return false;
	}
	
}
