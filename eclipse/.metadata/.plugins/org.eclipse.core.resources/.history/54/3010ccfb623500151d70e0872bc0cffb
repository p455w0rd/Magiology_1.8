package com.magiology.mcobjects.entitys;

import net.minecraft.block.Block;
import net.minecraft.client.particle.EntityFlameFX;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.IProjectile;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.MovingObjectPosition;
import net.minecraft.util.MovingObjectPosition.MovingObjectType;
import net.minecraft.util.Vec3;
import net.minecraft.world.World;

import com.magiology.objhelper.helpers.Cricle;
import com.magiology.objhelper.helpers.Helper;

import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;

public class EntitySubatomicWorldDeconstructor extends Entity implements IProjectile{
    public int xTile = -1,yTile = -1,zTile = -1,age;
    public Block block;
    
    public Entity shootingEntity;
    public double detonationTime=200;
    public int ticksInAir;
    public boolean isLaunched=false,targetHit=false;
    
    public EntitySubatomicWorldDeconstructor(World world)
    {
        super(world);
        this.renderDistanceWeight = 10.0D;
        this.setSize(0.5F, 0.5F);
    }

    public EntitySubatomicWorldDeconstructor(World world, double x, double y, double z){
        this(world);
        this.setPosition(x, y, z);
        this.yOffset = 0.0F;
    }
    
    public EntitySubatomicWorldDeconstructor(World world, EntityLivingBase entity, float speed){
    	Helper.printInln("g<piusgu<s");
        super(world);
        this.renderDistanceWeight = 10.0D;
        this.shootingEntity = entity;
        this.setSize(0.5F, 0.5F);
        this.setLocationAndAngles(entity.posX, entity.posY + entity.getEyeHeight(), entity.posZ, entity.rotationYaw, entity.rotationPitch);
        
        motionX=-Cricle.sin((int)this.rotationYaw)*Cricle.cos((int)this.rotationPitch)*speed;
        motionZ= Cricle.cos((int) this.rotationYaw)*Cricle.cos((int)(this.rotationPitch))*speed;
        motionY=-Cricle.sin((int) this.rotationPitch)*speed;
        
        double multiplayer=5,X=4,Y=-0.3,Z=4;
        
        this.posX-=Cricle.cos((int)rotationYaw)*0.1F-(Cricle.sin(-(int)this.rotationYaw)*Cricle.cos((int)this.rotationPitch))/multiplayer*X;
        this.posY-=-Y+Cricle.sin((int) this.rotationPitch)/multiplayer;
        this.posZ-=Cricle.sin((int)rotationYaw)*0.1F-(Cricle.cos(-(int) this.rotationYaw)*Cricle.cos((int)(this.rotationPitch)))/multiplayer*Z;
        
        this.setPosition(this.posX, this.posY, this.posZ);
        this.yOffset=0.0F;
        this.setThrowableHeading(this.motionX, this.motionY, this.motionZ, speed * 1.5F, 1.0F);
        this.dataWatcher.addObject(17, entity.getCommandSenderName());
    }

    @Override
	protected void entityInit()
    {
        this.dataWatcher.addObject(16, Byte.valueOf((byte)0));
    }
    
    @Override
	public void setThrowableHeading(double x, double y, double z, float var1, float var2){
    	
    }
    @Override
	@SideOnly(Side.CLIENT)
    public void setPositionAndRotation2(double p_70056_1_, double p_70056_3_, double p_70056_5_, float p_70056_7_, float p_70056_8_, int p_70056_9_){
        this.setPosition(p_70056_1_, p_70056_3_, p_70056_5_);
        this.setRotation(p_70056_7_, p_70056_8_);
    }
    
    @Override
	@SideOnly(Side.CLIENT)
    public void setVelocity(double p_70016_1_, double p_70016_3_, double p_70016_5_){
        this.motionX = p_70016_1_;
        this.motionY = p_70016_3_;
        this.motionZ = p_70016_5_;
    }
    @Override
	public void onUpdate(){
    	Helper.printInln("g<piusgu<s");
    	isDead=true;
    	super.onUpdate();
    	if(this.shootingEntity==null){
    		try {
        		shootingEntity=worldObj.getPlayerEntityByName(dataWatcher.getWatchableObjectString(17));
			} catch (Exception e){
//				e.printStackTrace();
			}
    	}
        age++;
        lastTickPosX=posX;
        lastTickPosY=posY;
        lastTickPosZ=posZ;
        Vec3 vec31 = Vec3.createVectorHelper(this.posX, this.posY, this.posZ);
        Vec3 vec3 = Vec3.createVectorHelper(this.posX + this.motionX, this.posY + this.motionY-0.05, this.posZ + this.motionZ);
        MovingObjectPosition MOP=worldObj.func_147447_a(vec31, vec3, true,true,false);
        block=worldObj.getBlock(xTile, yTile, zTile);
        if(MOP!=null&&MOP.typeOfHit!=MovingObjectType.MISS){
        	
            if(MOP.hitVec!=null){
                posX=MOP.hitVec.xCoord;
                posY=MOP.hitVec.yCoord;
                posZ=MOP.hitVec.zCoord;
                targetHit=true;
                Helper.spawnEntityFX(new EntityFlameFX(worldObj, MOP.hitVec.xCoord, MOP.hitVec.yCoord, MOP.hitVec.zCoord, 0, 0+(targetHit?0.1:0), 0));
            }
             
            if(MOP.typeOfHit==MovingObjectType.ENTITY){
            	
            	
            	
            }
        }else if(MOP!=null){
         	xTile=MOP.blockX;
         	yTile=MOP.blockY;
         	zTile=MOP.blockZ;
        }
//        targetHit=true;
        if(targetHit){
        	motionX*=0.1;
        	motionY*=0.1;
        	motionZ*=0.1;
        	motionY+=0.01;
        	detonationTime--;
        	if(detonationTime<=0)setDead();
        }
        Helper.spawnEntityFX(new EntityFlameFX(worldObj, posX, posY, posZ, 0, 0+(targetHit?0.1:0), 0));
        motionX*=0.99;
        motionY*=0.99;
        motionZ*=0.99;
        motionY-=0.04;
        
        motionX*=0;
        motionY*=0;
        motionZ*=0;
        this.moveEntity(motionX, motionY, motionZ);
    }
    
    @Override
	public void writeEntityToNBT(NBTTagCompound NBT){
        NBT.setShort("xTile",(short)this.xTile);
        NBT.setShort("yTile",(short)this.yTile);
        NBT.setFloat("zTile",(short)this.zTile);
        NBT.setByte("inTile",(byte)Block.getIdFromBlock(this.block));
    }
    @Override
	public void readEntityFromNBT(NBTTagCompound NBT){
        this.xTile=NBT.getShort("xTile");
        this.yTile=NBT.getShort("yTile");
        this.zTile=NBT.getShort("zTile");
        this.block=Block.getBlockById(NBT.getByte("inTile") & 255);
    }
    @Override
	public void writeToNBT(NBTTagCompound NBT){
    	super.writeToNBT(NBT);
    	writeEntityToNBT(NBT);
    }
    @Override
	public void readFromNBT(NBTTagCompound NBT){
    	super.readFromNBT(NBT);
    	readEntityFromNBT(NBT);
    }
    
    @Override
	@SideOnly(Side.CLIENT)
    public int getBrightnessForRender(float var1){
    	return 15728640;
    }
    
    @Override
	public void setDead(){
        this.isDead=true;
        if(!worldObj.isRemote){
    		worldObj.createExplosion(shootingEntity, posX, posY, posZ, 90, true);
        	for(int a=0;a<15;a++){
        		double[] b=Helper.createBallXYZ(20, false);
        		worldObj.createExplosion(shootingEntity, posX+b[0], posY+b[1], posZ+b[2], 50, true);
        	}
        	int pauwa=80;
        	for(int b=0;b<pauwa;b++){
        		EntityBallOfEnergy entity=new EntityBallOfEnergy(worldObj, posX, posY, posZ);
        		entity.setVelocity(Helper.CRandD(5), Helper.CRandD(5)-1, Helper.CRandD(5));
        		entity.time=430;
        		worldObj.spawnEntityInWorld(entity);
        	}
        }
        
    }
    
    /**
     * Called by a player entity when they collide with an entity
     */
    @Override
	public void onCollideWithPlayer(EntityPlayer player){
    	
    }
    
    @Override
	protected boolean canTriggerWalking(){return false;}
    @Override
	@SideOnly(Side.CLIENT)
    public float getShadowSize(){return 0.0F;}
    @Override
	public boolean canAttackWithItem(){return false;}
}