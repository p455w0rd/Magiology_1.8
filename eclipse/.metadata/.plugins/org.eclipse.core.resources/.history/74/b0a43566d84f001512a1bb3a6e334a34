package com.magiology.mcobjects.tileentityes.corecomponents.powertiles;

import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.server.gui.IUpdatePlayerListBox;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumFacing;

import com.magiology.api.connection.Connection;
import com.magiology.api.connection.ConnectionType;
import com.magiology.api.connection.IConnection;
import com.magiology.api.connection.IConnectionFactory;
import com.magiology.api.connection.IConnectionProvider;
import com.magiology.api.power.ISidedPower;
import com.magiology.api.power.PowerUpgrades;
import com.magiology.mcobjects.tileentityes.TileEntityBateryGeneric;
import com.magiology.mcobjects.tileentityes.TileEntityFirePipe;
import com.magiology.mcobjects.tileentityes.corecomponents.TileEntityM;
import com.magiology.mcobjects.tileentityes.corecomponents.UpdateableTile;
import com.magiology.objhelper.helpers.Helper;
import com.magiology.objhelper.helpers.LogHelper;
import com.magiology.objhelper.helpers.PowerHelper.PowerItemHelper;
import com.magiology.registry.upgrades.RegisterItemUpgrades.Container;

public abstract class TileEntityPow extends TileEntityM implements ISidedPower,PowerUpgrades,UpdateableTile,IUpdatePlayerListBox{
	public int currentEnergy=0,maxTSpeed=0,middleTSpeed=0,minTSpeed=1,maxEnergyBuffer=0;
	public boolean
		keepsPropertiesOnPickup=false,
		hasPriorityUpg=false;
	public int FirstSide=-1;
	
	public Container container=null;
	public int NumberOfContainerSlots=0;
	public ItemStack[] containerItems=null;
	
	public IConnection[] connections=IConnectionFactory.NewArray(this, ConnectionType.Energy);
	
	public TileEntityPow(boolean[] changeableByUser,boolean[] sidedPower,int minTSpeed, int middleTSpeed, int maxTSpeed, int maxEnergyBuffer){
		if(changeableByUser!=null)for(int i=0;i<6;i++){
			connections[i].setInEnabled(changeableByUser[i]);
			connections[i].setOutEnabled(changeableByUser[i+6]);
		}
		if(sidedPower!=null)for(int i=0;i<6;i++){
			connections[i].setIn(sidedPower[i]);
			connections[i].setOut(sidedPower[i+6]);
		}
		this.minTSpeed=minTSpeed;
		this.middleTSpeed=middleTSpeed;
		this.maxTSpeed=maxTSpeed;
		this.maxEnergyBuffer=maxEnergyBuffer;
	}
	
    @Override
	public void readFromNBT(NBTTagCompound NBTTC){
		super.readFromNBT(NBTTC);
        currentEnergy = NBTTC.getInteger("energy");
        
        containerItems=new ItemStack[NumberOfContainerSlots];
        containerItems=Helper.loadItemsFromNBT(NBTTC, "TEMT", containerItems);
        connections=readIConnections(this,NBTTC,"conData");
    }
    
    @Override
	public void writeToNBT(NBTTagCompound NBTTC){
		super.writeToNBT(NBTTC);
    	NBTTC.setInteger("energy", currentEnergy);
    	if(containerItems!=null){
    		Helper.saveItemsToNBT(NBTTC, "TEMT", containerItems);
        }
    	writeIConnections(getConnections(), NBTTC, "conData");
    }
    
    
    @Override
	public void initUpgrades(Container containe){
    	container=containe;
		NumberOfContainerSlots=container.getNumberOfTypes();
		setUpgradeSlots();
    }
    
    public void setUpgradeSlots(){
    	if(NumberOfContainerSlots>0)containerItems=new ItemStack[NumberOfContainerSlots];
    }
    
	public boolean isTPipe(BlockPos pos){
		return worldObj.getTileEntity(pos)instanceof TileEntityFirePipe;
	}
	

	public boolean canAcceptThatMuchEnergy(int amout){
		return (maxEnergyBuffer-amout>=currentEnergy?true:false);
	}
	
	public boolean isAnyBatery(BlockPos pos){
		boolean return1=false;
		TileEntity tile=worldObj.getTileEntity(pos);
		
		if(tile instanceof TileEntityBateryGeneric){
			return1=true;
		}
		
		return return1;
	}
	
	@Override
	public void addEnergy(int amount){currentEnergy+=amount;}
	@Override
	public void subtractEnergy(int amount){currentEnergy-=amount;}
    
    @Override
	public boolean isUpgradeInInv(Item item){
    	for(int a=0;a<NumberOfContainerSlots;a++){
    		if(Helper.isItemInStack(item, containerItems[a]))return true;
    	}
    	return false;
    }
	@Override
	public Container getContainer(){
		return container;
	}
	@Override
	public int getNumberOfContainerSlots(){
		return NumberOfContainerSlots;
	}
	@Override
	public ItemStack[] getcontainerItems(){
		return containerItems;
	}
	@Override
	public void setContainer(Container container){
		this.container=container;
	}
	@Override
	public void setNumberOfContainerSlots(int Int){
		NumberOfContainerSlots=Int;
	}
	@Override
	public void setcontainerItems(ItemStack[] containerItems){
		this.containerItems=containerItems;
	}
	@Override
	public boolean getReceiveOnSide(int direction){
		return connections[direction].getIn();
	}
	@Override
	public boolean getSendOnSide(int direction){
		return connections[direction].getOut();
	}
	@Override
	public void setReceaveOnSide(int direction, boolean bolean){
		connections[direction].setIn(bolean);
	}
	@Override
	public void setSendOnSide(int direction, boolean bolean){
		connections[direction].setOut(bolean);
	}
	@Override
	public int getEnergy(){
		return currentEnergy;
	}
	@Override
	public int getMaxTSpeed(){
		return maxTSpeed;
	}
	@Override
	public int getMiddleTSpeed(){
		return middleTSpeed;
	}
	@Override
	public int getMinTSpeed(){
		return minTSpeed;
	}
	@Override
	public int getMaxEnergy(){
		return maxEnergyBuffer;
	}
	@Override
	public void setEnergy(int Int){
		currentEnergy=Int;
	}
	@Override
	public void setMaxTSpeed(int Int){
		maxTSpeed=Int;
	}
	@Override
	public void setMiddleTSpeed(int Int){
		middleTSpeed=Int;
	}
	@Override
	public void setMinTSpeed(int Int){
		minTSpeed=Int;
	}
	@Override
	public void setMaxEnergyBuffer(int Int){
		maxEnergyBuffer=Int;
	}
	@Override
	public boolean getAllowedSender(int id){
		if(id<0||id>6){
			LogHelper.fatal(id);
			return false;
		}
		return connections[id].getOutEnabled();
	}
	@Override
	public boolean getAllowedReceaver(int id){
		if(id<0||id>6){
			LogHelper.fatal(id);
			return false;
		}
		return connections[id].getInEnabled();
	}
	@Override
	public void setAllowedSender(boolean Boolean, int id){
		connections[id].setOutEnabled(Boolean);
	}
	@Override
	public void setAllowedReceaver(boolean Boolean, int id){
		connections[id].setInEnabled(Boolean);
	}
	
	@Override
	public boolean getBannedSide(int id){
		return connections[id].isBanned();
	}
	@Override
	public void setBannedSide(boolean Boolean, int id){
		connections[id].setBanned(Boolean);
	}
	@Override
	public boolean isPowerKeptOnWrench(){
		return true;
	}
	@Override
	public void readFromItemOnPlace(ItemStack stack){
		setEnergy(PowerItemHelper.getPower(stack));
	}
	@Override
	public void writeToItemOnWrenched(ItemStack stack){
		PowerItemHelper.setEssencialPow(stack, this);
	}
	@Override
	public boolean isSavingFullNBT(){
		return true;
	}
	public static void writeIConnections(IConnection[] connections,NBTTagCompound NBT,String tag){
		NBTTagList list= new NBTTagList();
		for(int i=0;i<connections.length;i++){
			NBTTagCompound connection=new NBTTagCompound();
			IConnection con=connections[i];
			
			connection.setByte("face", (byte)con.getFaceI());
			connection.setByte("type", (byte)con.getType().id);
			connection.setBoolean("main", con.getMain());
			connection.setBoolean("in", con.getIn());
			connection.setBoolean("out", con.getOut());
			connection.setBoolean("banned", con.isBanned());
			connection.setBoolean("MA", con.isMainAutomatic());
			Set<Entry<String, String>> k=con.getAllExtra().entrySet();
			connection.setInteger("extraSize", k.size());
			int count=0;
			for(Entry<String, String> j:k){
				connection.setString("k"+count, j.getKey());
				connection.setString("v"+count, j.getValue());
				count++;
			}
			list.appendTag(connection);
		}
		NBT.setTag(tag+"Cons", list);
	}
	public static IConnection[] readIConnections(IConnectionProvider host,NBTTagCompound NBT, String tag){
		IConnection[] result=new IConnection[6]; 
		NBTTagList list= NBT.getTagList(tag+"Slots", 10);
		int size=6;
    	for(int i=0;i<list.tagCount();i++){
    		NBTTagCompound connection=list.getCompoundTagAt(i);
			result[i]=new Connection(host, 
			ConnectionType.values()[connection.getByte("type")], 
			EnumFacing.getFront(connection.getByte("face")));
			IConnection con=result[i];
			con.setMain(connection.getBoolean("main"));
    		con.setIn(connection.getBoolean("in"));
    		con.setOut(connection.getBoolean("out"));
    		con.setBanned(connection.getBoolean("banned"));
    		con.setIsMainAutomatic(connection.getBoolean("MA"));
    		int extraSize=connection.getInteger("extraSize");
    		for(int j=0;j<extraSize;j++)con.setExtra(connection.getString("k"+j), connection.getString("v"+j));
    	}
		return result;
	}
	@Override
	public TileEntity getHost(){
		return this;
	}
	@Override
	public IConnection[] getConnections(){
		return connections;
	}
	@Override
	public boolean isStrate(EnumFacing facing){
		if(facing==EnumFacing.UP||facing==EnumFacing.DOWN||facing==null){
			if((connections[0].getMain()&&connections[1].getMain())&&(connections[2].getMain()==false&&connections[3].getMain()==false&&connections[4].getMain()==false&&connections[5].getMain()==false))return true;
		}
		if(facing==EnumFacing.WEST||facing==null){
			if((connections[4].getMain()&&connections[5].getMain())&&(connections[1].getMain()==false&&connections[0].getMain()==false&&connections[2].getMain()==false&&connections[3].getMain()==false))return true;
		}
		if(facing==EnumFacing.SOUTH||facing==null){
			if((connections[2].getMain()&&connections[3].getMain())&&(connections[1].getMain()==false&&connections[0].getMain()==false&&connections[4].getMain()==false&&connections[5].getMain()==false))return true;
		}
		return false;
	}
}
