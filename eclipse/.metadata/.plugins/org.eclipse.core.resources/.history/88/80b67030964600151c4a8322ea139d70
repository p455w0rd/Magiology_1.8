package com.magiology.forgepowered.event;

import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Map.Entry;

import net.minecraft.block.Block;
import net.minecraft.client.renderer.ItemModelMesher;
import net.minecraft.client.renderer.block.model.BakedQuad;
import net.minecraft.client.renderer.block.model.FaceBakery;
import net.minecraft.client.renderer.block.model.ItemCameraTransforms;
import net.minecraft.client.renderer.texture.TextureAtlasSprite;
import net.minecraft.client.renderer.texture.TextureMap;
import net.minecraft.client.resources.model.IBakedModel;
import net.minecraft.client.resources.model.ModelResourceLocation;
import net.minecraft.client.resources.model.SimpleBakedModel;
import net.minecraft.item.Item;
import net.minecraft.util.EnumFacing;
import net.minecraftforge.client.event.ModelBakeEvent;
import net.minecraftforge.client.event.TextureStitchEvent;
import net.minecraftforge.fml.common.eventhandler.EventPriority;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

import org.apache.commons.lang3.ArrayUtils;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.magiology.mcobjects.blocks.BlockM;
import com.magiology.mcobjects.items.ItemM;
import com.magiology.objhelper.Get;
import com.magiology.objhelper.helpers.Helper;

public class ModelGenerator{
    public static TextureAtlasSprite[] icons;


    @SubscribeEvent
    // Allows us to add entries for our icons
    public void textureStitch(TextureStitchEvent.Pre event){
    	icons=null;
        TextureMap textureMap = event.map;
        for(Entry<Item, ModelResourceLocation> item:ItemM.modelsInit.entrySet()){
        	icons=ArrayUtils.add(icons, textureMap.registerSprite(item.getValue()));
        }
        Helper.printInln(icons);
        Helper.exit(404);
    }

    @SubscribeEvent(priority = EventPriority.LOWEST)
    // This allows us to create and add Baked Models to the registry
    public void bakeModels(ModelBakeEvent event){
    	BlockM.models = new IBakedModel[BlockM.modelsInit.size()];
    	BlockM.invmodels = new IBakedModel[BlockM.modelsInit.size()];
    	
        ItemModelMesher itemModelMesher = Get.Render.IMM();
        int i=0;
        for (Entry<Block, ModelResourceLocation> entry : BlockM.modelsInit.entrySet()) {
        	int id=i;
        	i++;
            Bakellator b=new Bakellator();
            
            // add to the registry
            event.modelRegistry.putObject(entry.getValue(), b.bake(icons[id]));

            // this creates the entry for the inventory block
            ModelResourceLocation inventory = new ModelResourceLocation(entry.getValue(), "inventory");

            // add to registry
            event.modelRegistry.putObject(inventory, b.bake(icons[id]));

            // register with the itemModelMesher
            itemModelMesher.register(Item.getItemFromBlock(entry.getKey()), 0, inventory);
        }
    }
    public static SimpleBakedModel changeIcon(IBakedModel model, TextureAtlasSprite texture) {
        SimpleBakedModel bakedModel = new SimpleBakedModel(new LinkedList(), newBlankFacingLists(), model.isGui3d(), model.isAmbientOcclusion(), texture, model.getItemCameraTransforms());

        for (Object o : model.getGeneralQuads()) {
            bakedModel.getGeneralQuads().add(changeTexture((BakedQuad) o, texture));
        }
        
        for (EnumFacing facing : EnumFacing.values()) {
            for (Object o : model.getFaceQuads(facing)) {
                bakedModel.getFaceQuads(facing).add(changeTexture((BakedQuad) o, texture));
            }
        }

        return bakedModel;
    }
    public static List newBlankFacingLists() {
        Object[] list = new Object[EnumFacing.values().length];
        for (int i = 0; i < EnumFacing.values().length; ++i) {
            list[i] = Lists.newLinkedList();
        }

        return ImmutableList.copyOf(list);
    }
    public static BakedQuad changeTexture(BakedQuad quad, TextureAtlasSprite tex) {
        quad = copyQuad(quad);

        // 4 vertexes on each quad
        for (int i = 0; i < 4; ++i) {
            int j = 7 * i;
            // get the x,y,z coordinates
            float x = Float.intBitsToFloat(quad.getVertexData()[j]);
            float y = Float.intBitsToFloat(quad.getVertexData()[j + 1]);
            float z = Float.intBitsToFloat(quad.getVertexData()[j + 2]);
            float u = 0.0F;
            float v = 0.0F;

            // move x,y,z in boundary if they are outside
            if (x < 0 || x > 1) x = (x + 1) % 1;
            if (y < 0 || y > 1) y = (y + 1) % 1;
            if (z < 0 || z > 1) z = (z + 1) % 1;


            // calculate the UVs based on the x,y,z and the 'face' of the quad
            switch (quad.getFace().ordinal()) {
                case 0:
                    u = x * 16.0F;
                    v = (1.0F - z) * 16.0F;
                    break;
                case 1:
                    u = x * 16.0F;
                    v = z * 16.0F;
                    break;
                case 2:
                    u = (1.0F - x) * 16.0F;
                    v = (1.0F - y) * 16.0F;
                    break;
                case 3:
                    u = x * 16.0F;
                    v = (1.0F - y) * 16.0F;
                    break;
                case 4:
                    u = z * 16.0F;
                    v = (1.0F - y) * 16.0F;
                    break;
                case 5:
                    u = (1.0F - z) * 16.0F;
                    v = (1.0F - y) * 16.0F;
            }

            // set the new texture uvs
            quad.getVertexData()[j + 4] = Float.floatToRawIntBits(tex.getInterpolatedU(u));
            quad.getVertexData()[j + 4 + 1] = Float.floatToRawIntBits(tex.getInterpolatedV(v));
        }

        return quad;
    }
    public static BakedQuad copyQuad(BakedQuad quad) {
        return new BakedQuad(Arrays.copyOf(quad.getVertexData(), quad.getVertexData().length), quad.getTintIndex(), quad.getFace());
    }
    public static class Bakellator {
        int side;

        int[] rawIntBuffer = new int[28];
        int vertexNo;
        int rawBufferIndex = 0;
        boolean isDrawing;
        int tintIndex;
        int color;

        LinkedList<BakedQuad> generalQuads;
        ArrayList<LinkedList<BakedQuad>> faceQuads;
        int normal;

        public Bakellator() {
            reset();
        }

        public SimpleBakedModel bake(TextureAtlasSprite texture) {
            return bake(texture, true, true, ItemCameraTransforms.DEFAULT);
        }

        public SimpleBakedModel bake(TextureAtlasSprite texture, boolean ambientOcclusion, boolean gui3d, ItemCameraTransforms camera) {
            SimpleBakedModel model = new SimpleBakedModel(generalQuads, faceQuads, ambientOcclusion, gui3d, texture, camera);
            reset();
            return model;
        }

        public void reset() {
            faceQuads = new ArrayList<LinkedList<BakedQuad>>(6);
            generalQuads = new LinkedList<BakedQuad>();
            for (int i = 0; i < 6; i++)
                faceQuads.set(i, new LinkedList<BakedQuad>());

            vertexNo = 0;
            side = 6;
            isDrawing = false;
            color = -1;
            tintIndex = -1;
            normal = 0;
        }

        public void setGeneral() {
            side = 6;
        }

        public void setFaceSide(int side) {
            this.side = side;
        }

        public void setFaceSide(EnumFacing facing) {
            side = facing.ordinal();
        }

        public void startDrawingQuads() {
            if (isDrawing)
                throw new RuntimeException("Already drawing");
            reset();
            isDrawing = true;
        }

        public void setTintIndex(int tintIndex) {
            this.tintIndex = tintIndex;
        }

        public void setColorOpaque_F(float r, float g, float b) {
            this.setColorOpaque((int) (r * 255.0F), (int) (g * 255.0F), (int) (b * 255.0F));
        }

        public void setColorRGBA_F(float r, float g, float b, float a) {
            this.setColorRGBA((int) (r * 255.0F), (int) (g * 255.0F), (int) (b * 255.0F), (int) (a * 255.0F));
        }

        public void setColorOpaque(int r, int g, int b) {
            this.setColorRGBA(r, g, b, 255);
        }

        public void setColorOpaque_I(int col) {
            int j = col >> 16 & 255;
            int k = col >> 8 & 255;
            int l = col & 255;
            this.setColorOpaque(j, k, l);
        }

        public void setColorRGBA_I(int col, int alpha) {
            int k = col >> 16 & 255;
            int l = col >> 8 & 255;
            int i1 = col & 255;
            this.setColorRGBA(k, l, i1, alpha);
        }


        public void setColorRGBA(int r, int g, int b, int a) {

            if (r > 255) {
                r = 255;
            }

            if (g > 255) {
                g = 255;
            }

            if (b > 255) {
                b = 255;
            }

            if (a > 255) {
                a = 255;
            }

            if (r < 0) {
                r = 0;
            }

            if (g < 0) {
                g = 0;
            }

            if (b < 0) {
                b = 0;
            }

            if (a < 0) {
                a = 0;
            }

            if (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN) {
                this.color = a << 24 | b << 16 | g << 8 | r;
            } else {
                this.color = r << 24 | g << 16 | b << 8 | a;
            }
        }

        public void setColorOpaque_B(byte p_154352_1_, byte p_154352_2_, byte p_154352_3_) {
            this.setColorOpaque(p_154352_1_ & 255, p_154352_2_ & 255, p_154352_3_ & 255);
        }

        public void setNormal(float p_78375_1_, float p_78375_2_, float p_78375_3_) {
            byte b0 = (byte) ((int) (p_78375_1_ * 127.0F));
            byte b1 = (byte) ((int) (p_78375_2_ * 127.0F));
            byte b2 = (byte) ((int) (p_78375_3_ * 127.0F));
            this.normal = b0 & 255 | (b1 & 255) << 8 | (b2 & 255) << 16;
        }


        public void addVertexWithUV(double x, double y, double z, double u, double v) {
            this.rawIntBuffer[this.rawBufferIndex] = Float.floatToRawIntBits((float) x);
            this.rawIntBuffer[this.rawBufferIndex + 1] = Float.floatToRawIntBits((float) y);
            this.rawIntBuffer[this.rawBufferIndex + 2] = Float.floatToRawIntBits((float) z);
            this.rawIntBuffer[this.rawBufferIndex + 3] = this.color;
            this.rawIntBuffer[this.rawBufferIndex + 4] = Float.floatToRawIntBits((float) u);
            this.rawIntBuffer[this.rawBufferIndex + 5] = Float.floatToRawIntBits((float) v);

            this.rawBufferIndex += 7;

            vertexNo++;

            if (vertexNo == 4) {
                BakedQuad quad = new BakedQuad(rawIntBuffer, tintIndex, FaceBakery.getFacingFromVertexData(rawIntBuffer));
                if (side == 6)
                    generalQuads.add(quad);
                else
                    faceQuads.get(side).add(quad);
            }

        }
    }
}